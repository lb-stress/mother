<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Alien Startup Simulation</title>
<style>
html, body {
  height: 100%;
  margin: 0;
  background: #000;
  display: flex;
  align-items: center;
  justify-content: center;
}
#crt {
  position: relative;
  width: 800px;
  height: 600px;
  background: #001a44;
  color: #6ec8ff;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  padding: 10px;
  box-shadow: 0 0 20px #001a44;
  border-radius: 20px;
  transform: perspective(1200px) rotateX(4deg) rotateY(-3deg);
}
canvas {
  image-rendering: pixelated;
}
#screen {
  width: 100%;
  height: 100%;
}
#noise {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.08;
  pointer-events: none;
  mix-blend-mode: overlay;
}
#start-msg {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #6ec8ff;
  background: #001a44;
  padding: 20px 40px;
  border: 1px solid #6ec8ff;
  cursor: pointer;
  text-shadow: 0 0 8px #6ec8ff;
}
</style>
</head>
<body>
<div id="crt">
  <canvas id="screen" width="800" height="600"></canvas>
  <canvas id="noise"></canvas>
  <div id="start-msg">Click to start</div>
</div>
<script>
const canvas = document.getElementById('screen');
const gl = canvas.getContext('webgl');
if (!gl) {
  alert('WebGL not supported');
} else {
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
}

const offscreen = document.createElement('canvas');
offscreen.width = canvas.width;
offscreen.height = canvas.height;
const ctx = offscreen.getContext('2d');

const noiseCanvas = document.getElementById('noise');
noiseCanvas.width = 100;
noiseCanvas.height = 75;
noiseCanvas.style.width = '100%';
noiseCanvas.style.height = '100%';
const noiseCtx = noiseCanvas.getContext('2d');

const rows = 25;
const cols = 10;
const colWidth = offscreen.width / cols;
const rowHeight = offscreen.height / rows;
ctx.font = Math.floor(rowHeight * 0.8) + 'px "Courier New", monospace';
ctx.textBaseline = 'top';
ctx.textAlign = 'left';

const data = Array.from({length: rows}, () => Array(cols).fill(''));
let currentCol = 0;

function randomDecimal() {
  return (Math.random() * 1000).toFixed(3);
}

function drawText() {
  ctx.fillStyle = 'rgba(0,26,68,0.15)';
  ctx.fillRect(0, 0, offscreen.width, offscreen.height);
  ctx.fillStyle = '#6ec8ff';
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c += 2) {
      const val = data[r][c];
      if (val) {
        ctx.fillText(val, c * colWidth + 2, r * rowHeight + 2);
      }
    }
  }
}

function renderNoise() {
  const imageData = noiseCtx.createImageData(noiseCanvas.width, noiseCanvas.height);
  for (let i = 0; i < imageData.data.length; i += 4) {
    const v = Math.random() * 255;
    imageData.data[i] = imageData.data[i + 1] = imageData.data[i + 2] = v;
    imageData.data[i + 3] = 50;
  }
  noiseCtx.putImageData(imageData, 0, 0);
}
// WebGL setup
const vertSrc = `
attribute vec2 a_position;
varying vec2 v_uv;
void main(){
  v_uv = (a_position + 1.0) * 0.5;
  gl_Position = vec4(a_position,0.0,1.0);
}`;

const fragSrc = `
precision mediump float;
uniform sampler2D u_texture;
varying vec2 v_uv;
void main(){
  vec2 uv = v_uv;
  vec2 center = uv - 0.5;
  float dist = dot(center, center);
  uv += center * dist * 0.3;
  vec3 color = texture2D(u_texture, uv).rgb;
  float off = 1.0 / 512.0;
  vec3 bloom = (
    texture2D(u_texture, uv + vec2(off,0.0)).rgb +
    texture2D(u_texture, uv - vec2(off,0.0)).rgb +
    texture2D(u_texture, uv + vec2(0.0,off)).rgb +
    texture2D(u_texture, uv - vec2(0.0,off)).rgb
  ) * 0.25;
  color += bloom * 0.4;
  float bright = max(max(color.r, color.g), color.b);
  color += color * bright * 0.2;
  gl_FragColor = vec4(color,1.0);
}`;

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}
function createProgram(gl, vert, frag) {
  const program = gl.createProgram();
  gl.attachShader(program, vert);
  gl.attachShader(program, frag);
  gl.linkProgram(program);
  return program;
}

const vert = createShader(gl, gl.VERTEX_SHADER, vertSrc);
const frag = createShader(gl, gl.FRAGMENT_SHADER, fragSrc);
const program = createProgram(gl, vert, frag);
gl.useProgram(program);

const positionLoc = gl.getAttribLocation(program, 'a_position');
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1, 1,-1, -1,1,
  -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

const texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.viewport(0, 0, canvas.width, canvas.height);

function render() {
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, offscreen);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function tick() {
  const bottomRow = data[rows - 1];
  bottomRow[currentCol] = randomDecimal();
  currentCol += 2;
  if (currentCol >= cols) {
    playSound();
    data.push(Array(cols).fill(''));
    data.shift();
    currentCol = 0;
  }
  drawText();
  render();
  renderNoise();
}

let interval;
function start() {
  document.getElementById('start-msg').style.display = 'none';
  drawText();
  render();
  interval = setInterval(tick, 50);
}

const startMsg = document.getElementById('start-msg');
startMsg.addEventListener('click', () => {
  initAudio();
  start();
});

let audioCtx;
function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function playSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'square';
  const startFreq = 400 + Math.random() * 200;
  osc.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
  osc.frequency.linearRampToValueAtTime(80, audioCtx.currentTime + 0.2);
  gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.2);
  const bufferSize = audioCtx.sampleRate * 0.2;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = Math.random() * 2 - 1;
  }
  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  const noiseGain = audioCtx.createGain();
  noiseGain.gain.value = 0.02;
  noise.connect(noiseGain).connect(audioCtx.destination);
  noise.start();
  noise.stop(audioCtx.currentTime + 0.2);
}
</script>
</body>
</html>
